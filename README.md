# 테이블 연결성 분석 및 병합 도구

PDF 문서에서 여러 페이지에 걸쳐 이어지는 테이블들을 자동으로 찾아서 병합하고 시각화하는 도구입니다.

## 프로젝트 구조

이 프로젝트는 두 가지 버전으로 구성되어 있습니다:

- **[docling_version/](docling_version/)**: GPU 가속을 지원하는 docling 기반 (빠른 처리 속도)
- **[opendataloader_version/](opendataloader_version/)**: Java 기반 opendataloader-pdf (설치 간편)

각 버전은 독립적으로 실행 가능하며, 동일한 병합 로직과 규칙을 사용합니다.

자세한 내용은 [README_프로젝트구조.md](README_프로젝트구조.md) 참조

## 주요 기능

- ✅ **텍스트 연결성 분석**: 테이블 간 텍스트가 자연스럽게 이어지는지 감지
- ✅ **헤더 비교**: 동일한 헤더를 가진 테이블 자동 병합
- ✅ **타이틀 기반 분리**: 서로 다른 타이틀을 가진 테이블은 별도로 처리
- ✅ **헤더+데이터 구조 인식**: 헤더가 있는 테이블과 데이터만 있는 테이블 연결
- ✅ **원본 PDF 시각화**: 연결된 테이블을 색깔별로 표시
- ✅ **상세 보고서**: 각 연결의 근거가 되는 텍스트 비교 정보 제공

## 빠른 시작

### Docling 버전 (GPU 가속)

```bash
cd docling_version
python check_gpu.py  # GPU 상태 확인
python extract_tables_from_json.py  # 테이블 추출
python merge_connected_tables.py  # 테이블 병합
python visualize_connected_tables.py  # 시각화
```

### Opendataloader 버전 (간편 설치)

```bash
cd opendataloader_version
python run_all_v2.py  # 전체 파이프라인 실행 (추출+병합+시각화+오버레이)
```

## 상세 사용 방법

각 버전의 상세한 사용 방법은 해당 폴더의 README.md를 참조하세요:

- [docling_version/README.md](docling_version/README.md)
- [opendataloader_version/README.md](opendataloader_version/README.md)

## 설치

```bash
pip install -r requirements.txt
```

## 이전 버전 사용 방법 (참고용)

### 0. GPU 가속 상태 확인 (선택)

```bash
cd docling_version
python check_gpu.py
```

### 1. 테이블 데이터 준비

**옵션 A: 직접 준비**
`docling_version/table_output/` 디렉토리에 분석할 JSON 파일들을 위치시킵니다.

**옵션 B: output 폴더에서 추출**
```bash
cd docling_version
python extract_tables_from_json.py
```

### 2. 테이블 병합 실행

```bash
cd docling_version
python merge_connected_tables.py
```

**출력 결과:**
- `merged_tables_output/*_merged.json`: 각 파일별 병합 결과
- `merged_tables_output/merge_summary.json`: 전체 요약
- `merged_tables_output/merged_tables_visualization.pdf`: 시각화 PDF

### 3. 상세 시각화 생성 (선택)

```bash
python visualize_connected_tables.py
```

**출력 결과:**
- `visualized_pdfs/*_connected_tables.pdf`: 원본 PDF에 연결 테이블 표시
- `visualized_pdfs/연결된_테이블_설명.pdf`: 상세 설명 및 텍스트 비교

## 테이블 병합 규칙

### 📋 연결 규칙 (우선순위 순)

#### 1. 타이틀 기반 분리 (최우선)
**둘 다 타이틀이 있는 경우:**
- ✅ **완전 일치** → 같은 테이블 (유사도 1.0)
- ✅ **포함 관계** → 같은 테이블 (유사도 0.8)
  - 예: "표 3.1 제목" ⊆ "표 3.1 제목 (계속)"
- ❌ **그 외 모든 경우** → 다른 테이블 (유사도 0.0)
  - 예: "표 3.1 제목" ≠ "표 3.2 제목"
  - 예: "4. 시험장 위치(1군)" ≠ "5. 시험장 위치(2군)"

**같은 페이지 + 타이틀 다름:**
- 유사도 80% 미만이면 무조건 분리
- 예: 같은 페이지에 있는 "표 5.4" 와 "표 5.5"

**두 번째 테이블에만 타이틀:**
- 새로운 섹션 시작으로 간주하여 분리
- 헤더가 같아도 분리

#### 2. 텍스트 연결성 🔗
**감지 방법:**
- 첫 번째 테이블의 마지막 5개 셀 vs 두 번째 테이블의 첫 5개 셀 비교
- 텍스트가 이어지는 패턴 확인

**연결 패턴:**
- **숫자 순서**: `1)` → `2)`, `가.` → `나.`, `①` → `②`
- **한글 순서**: `가.` → `나.`, `ㄱ.` → `ㄴ.`
- **단어 잘림**: "국가재난관리" → "국가재난관리시스템" (최소 5자 이상)
- **불완전한 문장**: "~의", "~를", "~및", "~와" 등으로 끝나는 경우

**예시:**
```
테이블 1 끝: "재난관리 기본법에 따라"
테이블 2 시작: "기본법에 따라 다음과 같이"
→ 연결됨 (단어 잘림)
```

#### 3. 헤더 동일 📋
**조건:**
- 두 테이블 모두 헤더 있음
- 헤더 개수 각각 최소 2개 이상
- 공통 헤더 최소 2개 이상
- 유사도 60% 이상

**검증:**
- 키값(첫 번째 열) 중복 체크
- 30% 이상 중복시 다른 테이블로 판단

**예시:**
```
테이블 1: [구분, 항목, 내용, 비고]
테이블 2: [구분, 항목, 내용, 비고]
→ 연결됨 (4개 일치, 100%)
```

#### 4. 헤더 + 데이터 구조 📊
**조건:**
- 첫 번째 테이블: 헤더 있음
- 두 번째 테이블: 헤더 없음 (데이터만)
- 연속 페이지 (1페이지 차이)

**타이틀이 있는 경우:**
- 첫 번째 테이블에 타이틀 있고 연속 페이지면 연결

**텍스트 연결이 있는 경우:**
- 연결성 감지시 연결

#### 5. 타이틀 있는 데이터 테이블 연속
**조건:**
- 첫 번째: 타이틀 있음, 헤더 없음
- 두 번째: 타이틀 없음, 헤더 없음
- 열 개수 정확히 동일
- 연속 페이지 (1페이지 차이)

**예시:**
```
테이블 1: 타이틀="표 5.9 결과", 헤더 없음, 3열
테이블 2: 타이틀 없음, 헤더 없음, 3열
→ 연결됨
```

#### 6. 헤더 없는 데이터 테이블 연속
**조건:**
- 둘 다 타이틀 없음, 헤더 없음
- 연속 페이지 (1페이지 차이)
- 열 개수 차이 1개 이하
- 최소 2열 이상

**키값 중복 체크:**
- 첫 번째 열 데이터 비교
- 50% 이상 중복시 반복 테이블로 간주하여 분리
  - 예: 요구사항 템플릿이 반복되는 경우

### ❌ 분리 규칙

#### 필수 분리 조건:
1. **페이지 차이**: 2페이지 이상 떨어진 경우
2. **구조 차이**: 열 개수 차이 2개 초과
3. **타이틀 불일치**:
   - 둘 다 타이틀 있고 포함 관계가 아닌 경우
   - 같은 페이지 + 타이틀 유사도 80% 미만
4. **새로운 타이틀**: 두 번째 테이블에만 타이틀이 있는 경우
5. **키값 중복**: 헤더는 같지만 데이터 행이 30% 이상 중복
6. **반복 테이블**: 헤더 없는 테이블의 키값이 50% 이상 중복

#### 특수 분리:
- **페이지 헤더 필터링**: "제X장", "숫자 │ 제목" 패턴은 타이틀에서 제외
- **페이지 번호 필터링**: 순수 숫자나 3자 미만 텍스트는 타이틀에서 제외

## 타이틀 추출 방법

### 추출 위치
- 테이블 상단 300px 이내의 텍스트 검색
- 거리가 가까운 순서대로 우선순위

### 타이틀 필터링
**제외되는 텍스트:**
1. 숫자만 있는 경우 (페이지 번호)
2. 3자 미만의 짧은 텍스트
3. 페이지 헤더 패턴:
   - "제X장"으로 시작하는 경우
   - "숫자 │ 텍스트" 패턴 (예: "88 │ 재난원인조사...")
4. 다른 테이블 내부의 텍스트 (50px 초과 거리일 때만)

### 멀티 로우 헤더 처리
- 같은 열에 여러 행에 걸친 헤더가 있는 경우
- 각 열에서 가장 긴(구체적인) 텍스트를 헤더로 선택
- 헤더가 1개만 있으면 헤더가 아닌 것으로 간주

## 처리 순서

```
1. 테이블 정보 추출
   ├─ 타이틀 추출 (상단 300px 이내)
   ├─ 헤더 추출 (column_header flag)
   ├─ 키값 추출 (첫 번째 열 데이터)
   └─ 구조 정보 (행/열 개수)

2. 페이지 순서대로 정렬

3. 연결성 체크 (순차적으로)
   ├─ 페이지 차이 확인 (0-2 페이지)
   ├─ 구조 유사성 확인 (열 차이 ≤2)
   ├─ 타이틀 비교 (최우선)
   ├─ 텍스트 연결 확인
   ├─ 헤더 비교
   └─ 특수 패턴 확인 (헤더+데이터 등)

4. 그룹핑
   ├─ 연결된 테이블들을 그룹으로 묶기
   ├─ 단일 테이블은 별도 관리
   └─ 비연속 이유 저장

5. 병합 및 저장
   └─ JSON 파일 및 PDF 생성
```

## 디렉토리 구조

```
표_연속성체크_04/
├── input/                          # 원본 PDF 파일
├── output/                         # DocLayNet JSON 파일 (원본)
├── table_output/                   # 테이블 JSON 데이터 (추출됨)
├── merged_tables_output/           # 병합 결과
│   ├── *_merged.json              # 각 파일별 병합 결과
│   ├── merge_summary.json         # 전체 요약
│   └── merged_tables_visualization.pdf  # 통합 시각화
├── visualized_pdfs/               # 상세 시각화 결과 (선택)
│   ├── *_connected_tables.pdf    # 오버레이된 PDF
│   └── 연결된_테이블_설명.pdf      # 상세 설명
├── extract_tables_from_json.py    # 테이블 추출 스크립트
├── merge_connected_tables.py      # 병합 스크립트 (메인)
└── visualize_connected_tables.py  # 상세 시각화 스크립트
```

## 출력 예시

### 병합 결과 (콘솔)
```
처리 중: 재난원인조사_tables.json
  총 테이블 수: 99
  병합된 그룹 수: 12
  단일 테이블 수: 74

  그룹 1:
    테이블 인덱스: [9, 10]
    페이지: [32, 33]
    테이블 9 타이틀: 표 2.2 우리나라 개별 재난 ․ 사고 조사기구
    - Table 9 -> 10: 텍스트 연결: '한국농어촌공사 등' -> '재난·사고유형'
    - (비연속) Table 10 -X-> 11: 두 번째 테이블에 새로운 타이틀 시작

  그룹 2:
    테이블 인덱스: [17, 18]
    페이지: [41, 42]
    - Table 17 -> 18: 헤더가 동일함 (7개 일치)
```

### 병합 결과 JSON
```json
{
  "source_file": "table_output/파일_tables.json",
  "original_table_count": 52,
  "merged_groups": [
    {
      "group_id": 0,
      "table_indices": [4, 5],
      "pages": [10, 11],
      "connection_reasons": [
        "Table 4 -> 5: 헤더가 동일함 (4개 일치)"
      ],
      "disconnection_reasons": [
        "Table 5 -X-> 6: 두 번째 테이블에 새로운 타이틀 시작"
      ],
      "merged_table": { /* 병합된 테이블 데이터 */ }
    }
  ],
  "single_tables": [ /* 단일 테이블 정보 */ ],
  "table_infos": [ /* 모든 테이블의 타이틀 등 메타데이터 */ ]
}
```

### 시각화 PDF
- 같은 색상 = 연결된 테이블 그룹
- 각 박스에 "그룹 N" 레이블 표시
- 원본 내용 유지 (오버레이 방식)

## 요구사항

- Python 3.8+
- reportlab: PDF 생성
- PyPDF2: PDF 처리
- docling: PDF 파싱 (GPU 가속 지원)
- torch: GPU 가속 (선택사항)

### GPU 가속 (선택사항, 권장)

Docling은 GPU를 사용하여 3-6배 빠른 처리가 가능합니다.

```bash
python -c "import torch; print(f'GPU: {torch.cuda.is_available()}')"
```

## 참고

- 이 도구는 DocLayNet 형식의 테이블 데이터를 사용합니다
- 한글 폰트는 Windows의 `malgun.ttf`를 사용합니다
- PDF 생성 시 A4 크기 기준으로 작성됩니다
- 테이블 병합은 순차적으로만 진행되며 건너뛰기는 불가능합니다
