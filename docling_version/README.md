# 테이블 연결성 분석 및 병합 도구

PDF 문서에서 여러 페이지에 걸쳐 이어지는 테이블들을 자동으로 찾아서 병합하고 시각화하는 도구입니다.

## 주요 기능

- ✅ **병렬 처리**: CPU 멀티코어 활용으로 빠른 테이블 비교 및 병합
- ✅ **헤더 비교**: 동일한 헤더를 가진 테이블 자동 병합
- ✅ **타이틀 기반 분리**: 서로 다른 타이틀을 가진 테이블은 별도로 처리
- ✅ **구조 기반 병합**: 열 개수, 테이블 너비 등 구조적 유사성 검증
- ✅ **원본 PDF 시각화**: 연결된 테이블을 색깔별로 표시
- ✅ **상세 보고서**: 각 연결/분리 이유 상세 기록
- ✅ **안전한 파일명 처리**: Windows 특수문자 자동 변환

## 설치

```bash
pip install -r requirements.txt
```

## 사용 방법

### 0. 파일명 정리 (최초 1회)

Windows에서 사용할 수 없는 문자(`+`, `:`, `?` 등)를 `_`로 변경합니다.

```bash
# JSON 파일명 정리
python rename_json_files.py

# PDF 파일명 정리
python rename_pdf_files.py
```

### 1. GPU 가속 상태 확인 (선택)

```bash
python check_gpu.py
```

### 2. 테이블 데이터 준비

**옵션 A: 직접 준비**
`table_output/` 디렉토리에 분석할 JSON 파일들을 위치시킵니다.

**옵션 B: output 폴더에서 추출**
```bash
python extract_tables_from_json.py
```

### 3. 테이블 병합 실행

```bash
python merge_connected_tables.py
```

**병렬 처리 옵션:**
- 기본값: CPU 코어 수만큼 병렬 처리
- 순차 처리: `use_parallel=False` 옵션으로 변경 가능
- 워커 수 조정: `max_workers=4` 등으로 설정 가능

**출력 결과:**
- `merged_tables_output/*_merged.json`: 각 파일별 병합 결과
- `merged_tables_output/merge_summary.json`: 전체 요약
- `merged_tables_output/merged_tables_visualization.pdf`: 시각화 PDF

### 4. 상세 시각화 생성 (선택)

```bash
python visualize_connected_tables.py
```

**출력 결과:**
- `visualized_pdfs/*_connected_tables.pdf`: 원본 PDF에 연결 테이블 표시
- `visualized_pdfs/연결된_테이블_설명.pdf`: 상세 설명

## 테이블 병합 규칙

### 📋 연결 규칙 (우선순위 순)

#### 1. 타이틀 기반 분리 (최우선)
**둘 다 타이틀이 있는 경우:**
- ✅ **완전 일치** → 같은 테이블 (유사도 1.0)
- ✅ **높은 유사도** → 같은 테이블 (유사도 ≥ 0.85)
  - 예: "표 3.1 제목" ≈ "표 3.1 제목 (계속)"
- ❌ **낮은 유사도** → 다른 테이블 (유사도 < 0.85)
  - 예: "표 3.1 제목" ≠ "표 3.2 제목"
  - 예: "4. 시험장 위치(1군)" ≠ "5. 시험장 위치(2군)"

**타이틀 유사도 계산:**
- 숫자만 다른 경우(예: "표 3.3" vs "표 3.4") → 0.0 (다른 테이블)
- 전체 유사도 85% 이상 → 같은 테이블
- 전체 유사도 85% 미만 → 다른 테이블

**같은 페이지 + 타이틀 다름:**
- 유사도 80% 미만이면 무조건 분리
- 예: 같은 페이지에 있는 "표 5.4" 와 "표 5.5"

**두 번째 테이블에만 타이틀:**
- 새로운 섹션 시작으로 간주하여 분리
- 헤더가 같아도 분리

#### 2. 헤더 동일 📋
**조건:**
- 두 테이블 모두 헤더 있음
- 헤더 개수 각각 최소 2개 이상
- 공통 헤더 최소 2개 이상 (100% 일치) 또는
- 부분 일치 헤더 2개 이상 (50% 이상 포함 관계)

**검증:**
- 키값(첫 번째 열) 중복 체크
- 30% 이상 중복시 다른 테이블로 판단 (반복 테이블)

**예시:**
```
테이블 1: [구분, 항목, 내용, 비고]
테이블 2: [구분, 항목, 내용, 비고]
→ 연결됨 (4개 일치, 100%)
```

#### 3. 헤더 + 데이터 구조 📊
**조건:**
- 첫 번째 테이블: 헤더 있음
- 두 번째 테이블: 헤더 없음 (데이터만)
- 연속 페이지 (1페이지 차이)

**타이틀이 있는 경우:**
- 타이틀 있음
- 열 개수 차이 ≤ 1
- 테이블 너비 차이 ≤ 20%
- → 연결됨

**타이틀이 없는 경우:**
- 열 개수 정확히 일치
- 테이블 너비 차이 ≤ 10%
- → 연결됨 (더 엄격한 조건)

#### 4. 헤더 없는 데이터 테이블 연속
**조건:**
- 둘 다 타이틀 없음, 헤더 없음
- 연속 페이지 (1페이지 차이)
- 열 개수 차이 1개 이하
- 최소 2열 이상

**키값 중복 체크:**
- 첫 번째 열 데이터 비교
- 50% 이상 중복시 반복 테이블로 간주하여 분리
  - 예: 요구사항 템플릿이 반복되는 경우

### ❌ 분리 규칙

#### 필수 분리 조건:
1. **페이지 차이**: 2페이지 이상 떨어진 경우
2. **구조 차이**: `has_similar_structure()` 실패
3. **타이틀 불일치**:
   - 둘 다 타이틀 있고 유사도 < 0.85
   - 같은 페이지 + 타이틀 유사도 < 0.80
   - 표 번호만 다른 경우 (예: "표 3.3" vs "표 3.4") → 유사도 0.0
4. **새로운 타이틀**: 두 번째 테이블에만 타이틀이 있는 경우
5. **키값 중복**:
   - 헤더는 같지만 데이터 행(첫 번째 열)이 30% 이상 중복
   - 헤더 없는 테이블의 키값이 50% 이상 중복
6. **반복 헤더/푸터**: 문서 전체에서 3회 이상 반복되는 텍스트는 타이틀에서 제외

#### 특수 필터링:
- **타이틀 제외 패턴**:
  - "제X장"으로 시작
  - "숫자 │ 제목" 패턴 (페이지 헤더)
  - 순수 숫자만 있는 경우 (페이지 번호)
  - 3자 미만 텍스트
  - 다른 테이블 내부의 텍스트 (거리 50px 초과일 때만)

- **텍스트 연결성 사용 안 함**: 오탐이 많아 비활성화됨

## 타이틀 추출 방법

### 추출 위치
- 테이블 상단 300px 이내의 텍스트 검색
- 거리가 가까운 순서대로 우선순위

### 타이틀 필터링
**제외되는 텍스트:**
1. 숫자만 있는 경우 (페이지 번호)
2. 3자 미만의 짧은 텍스트
3. 페이지 헤더 패턴:
   - "제X장"으로 시작하는 경우
   - "숫자 │ 텍스트" 패턴 (예: "88 │ 재난원인조사...")
4. 다른 테이블 내부의 텍스트 (50px 초과 거리일 때만)

### 멀티 로우 헤더 처리
- 같은 열에 여러 행에 걸친 헤더가 있는 경우
- 각 열에서 가장 긴(구체적인) 텍스트를 헤더로 선택
- 헤더가 1개만 있으면 헤더가 아닌 것으로 간주

## 처리 순서 및 성능 최적화

```
1. 테이블 정보 추출
   ├─ 타이틀 추출 (상단 300px 이내)
   ├─ 헤더 추출 (column_header flag)
   ├─ 키값 추출 (첫 번째 열 데이터)
   └─ 구조 정보 (행/열 개수, 테이블 너비)

2. 페이지 순서대로 정렬

3. 연결성 체크 (병렬 처리)
   ├─ [병렬] 모든 인접 테이블 쌍을 동시에 비교 (ProcessPoolExecutor)
   │   └─ 각 쌍 내에서 4가지 조건을 병렬로 체크 (ThreadPoolExecutor)
   │       ├─ 타이틀 유사도 계산
   │       ├─ 헤더 유사도 계산
   │       ├─ 테이블 너비 계산
   │       └─ (텍스트 연결성 - 비활성화됨)
   ├─ 결과 캐싱 및 재사용
   └─ 연결성 판단
       ├─ 페이지 차이 확인 (0-2 페이지)
       ├─ 구조 유사성 확인
       ├─ 타이틀 비교 (최우선)
       ├─ 헤더 비교
       └─ 구조 기반 병합 (열/너비)

4. 그룹핑
   ├─ 연결된 테이블들을 그룹으로 묶기
   ├─ 단일 테이블은 별도 관리
   └─ 비연속 이유 저장

5. 병합 및 저장
   └─ JSON 파일 및 PDF 생성
```

### 성능 최적화
- **2단계 병렬화**:
  - 1단계: 테이블 쌍 비교 병렬화 (ProcessPoolExecutor)
  - 2단계: 각 쌍의 조건 체크 병렬화 (ThreadPoolExecutor)
- **예상 성능 향상**:
  - N개 테이블, M코어 CPU → 약 M배 빠름
  - 각 쌍마다 4개 조건 동시 체크 → 추가 성능 향상
  - 실제 성능은 테이블 수, CPU 코어 수에 따라 달라짐

## 디렉토리 구조

```
표_연속성체크_04/
├── input/                          # 원본 PDF 파일
├── output/                         # DocLayNet JSON 파일 (원본)
├── table_output/                   # 테이블 JSON 데이터 (추출됨)
├── merged_tables_output/           # 병합 결과
│   ├── *_merged.json              # 각 파일별 병합 결과
│   ├── merge_summary.json         # 전체 요약
│   └── merged_tables_visualization.pdf  # 통합 시각화
├── visualized_pdfs/               # 상세 시각화 결과 (선택)
│   ├── *_connected_tables.pdf    # 오버레이된 PDF
│   └── 연결된_테이블_설명.pdf      # 상세 설명
├── extract_tables_from_json.py    # 테이블 추출 스크립트
├── merge_connected_tables.py      # 병합 스크립트 (메인, 병렬 처리)
├── visualize_connected_tables.py  # 상세 시각화 스크립트
├── rename_json_files.py           # JSON 파일명 정리 (특수문자 변환)
└── rename_pdf_files.py            # PDF 파일명 정리 (특수문자 변환)
```

## 출력 예시

### 병합 결과 (콘솔)
```
처리 중: 재난원인조사_tables.json
  총 테이블 수: 99
  원본 JSON에서 1177개 텍스트 로드
  감지된 반복 패턴 2개: ['페이지 헤더', '푸터 텍스트']
  병합된 그룹 수: 6
  단일 테이블 수: 87

  그룹 1:
    테이블 인덱스: [9, 10]
    페이지: [32, 33]
    테이블 9 타이틀: 표 2.2 우리나라 개별 재난 ․ 사고 조사기구
    - Table 9 -> 10: 헤더가 동일함 (5개 일치)
    - (비연속) Table 10 -X-> 11: 두 번째 테이블에 새로운 타이틀 시작 ('표 2.3...')

  그룹 2:
    테이블 인덱스: [17, 18]
    페이지: [41, 42]
    테이블 17 타이틀: 표 2.9 행정안전부 주관 재난원인조사 개선권고 현황
    - Table 17 -> 18: 헤더가 동일함 (5개 일치)
    - (비연속) Table 18 -X-> 19: 두 번째 테이블에 새로운 타이틀 시작
```

### 병합 결과 JSON
```json
{
  "source_file": "table_output/파일_tables.json",
  "original_table_count": 52,
  "merged_groups": [
    {
      "group_id": 0,
      "table_indices": [4, 5],
      "pages": [10, 11],
      "connection_reasons": [
        "Table 4 -> 5: 헤더가 동일함 (4개 일치)"
      ],
      "disconnection_reasons": [
        "Table 5 -X-> 6: 두 번째 테이블에 새로운 타이틀 시작"
      ],
      "merged_table": { /* 병합된 테이블 데이터 */ }
    }
  ],
  "single_tables": [ /* 단일 테이블 정보 */ ],
  "table_infos": [ /* 모든 테이블의 타이틀 등 메타데이터 */ ]
}
```

### 시각화 PDF
- 같은 색상 = 연결된 테이블 그룹
- 각 박스에 "그룹 N" 레이블 표시
- 원본 내용 유지 (오버레이 방식)

## 요구사항

- Python 3.8+
- reportlab: PDF 생성
- PyPDF2: PDF 처리
- docling: PDF 파싱 (GPU 가속 지원)
- torch: GPU 가속 (선택사항)

### GPU 가속 (선택사항, 권장)

Docling은 GPU를 사용하여 3-6배 빠른 처리가 가능합니다.

```bash
python -c "import torch; print(f'GPU: {torch.cuda.is_available()}')"
```

## 참고

- 이 도구는 DocLayNet 형식의 테이블 데이터를 사용합니다
- 한글 폰트는 Windows의 `malgun.ttf`를 사용합니다
- PDF 생성 시 A4 크기 기준으로 작성됩니다
- 테이블 병합은 순차적으로만 진행되며 건너뛰기는 불가능합니다
